// shelljs ( https://github.com/shelljs/shelljs )

import "./webpack"

import React from "react"
import shell from "shelljs"
import fs from "fs"
import path from "path"
import renderDoc from "./doc/renderDoc"

import ModelDocs from "./doc/ModelDocs"
import ComponentDocs from "./doc/ComponentDocs"
import ExpressionDocs from "./doc/ExpressionDocs"
import ExtensionDir, { makeTree } from "./doc/ExtensionDir"
import ComponentClassIndex from "./doc/ComponentClassIndex"
import Markdown from "./doc/Markdown"
import InfoBlock from "../src/main/js/components/std/common/InfoBlock";
import prioritySort from "./doc/priority-sort"

const MODEL_DOCS_PATH = "../src/main/base/resources/js/model-docs.json";

const DOC_SOURCE = "src/main/doc";

const OUTPUT = "target/classes/exceed-docs";

if (shell.test("-d", OUTPUT))
{
    shell.rm("-R", OUTPUT);
}

shell.cp("-R", DOC_SOURCE + "/theme", OUTPUT);
shell.cp(DOC_SOURCE + "/media/*", OUTPUT + "/media");


/**
 * ModelDocs data resulting from the current state of annotated java source files for models.
 * Data generated by de.quinscape.exceed.tooling.GenerateModelDocs
 */
const modelDocsData = JSON.parse(fs.readFileSync(path.join(__dirname, MODEL_DOCS_PATH), "UTF-8"));

//console.log({modelDocsData});

if (!modelDocsData)
{
    throw new Error("Cannot read " + MODEL_DOCS_PATH);
}

const componentData = {
    names : [],
    descriptors: {}
};

/**
 * Read all current components.json files
 */
shell.find( "src/main/js/components/std/**/components.json").forEach(file => {
    const json = fs.readFileSync(file, "UTF-8");

    try
    {
        const { components } = JSON.parse(json);

        for (let name in components)
        {
            if (components.hasOwnProperty(name))
            {
                const d = components[name];
                d.pkg = file;

                componentData.names.push(name);
                componentData.descriptors[name] = d;
            }
        }
    }
    catch(e)
    {
        console.error("Error reading " + file, e);
    }

});

componentData.names = componentData.names.sort();


function ExtensionStructure(props)
{
    const { locations, filter } = props;

    const tree = makeTree(locations, filter);

    const last = tree.kids[tree.kids.length-1];

    return(
        <ul className="extension-struct">
            {
                tree.kids && tree.kids.map( kid => <ExtensionDir key={ kid.name } {...kid} last={ kid === last} filter={ filter }/> )
            }
        </ul>
    );
}

const markDownPages = [];

/**
 * Read markdown docs
 */
shell.find( DOC_SOURCE + "/*.md").forEach(file => {

    const content = fs.readFileSync(file, "UTF-8");

    const title = /(.*)\n/.exec(content)[1];

    markDownPages.push({
        name: path.basename(file, ".md"),
        title: title,
        component:

            <Markdown
                data={ content }

                // ad hoc embedded components in markdown. Use ~~ExtensionStructure~~ to embed.
                components={
                    {
                        ExtensionStructure: <ExtensionStructure { ... modelDocsData }/>,
                        DomainStructure: <ExtensionStructure { ... modelDocsData } filter={ /domain/ }/>,
                        ViewStructure: <ExtensionStructure { ... modelDocsData } filter={ /view|layout/ }/>,
                        ProcessStructure: <ExtensionStructure { ... modelDocsData } filter={ /process/ }/>,

                        InfoReact:
                            <InfoBlock heading="Implementation Note: React">
                                <p>
                                    As you might have guessed, the components are not the only react components involved in exceed views.
                                    The views themselves are transformed into a react component.
                                </p>
                                <p>
                                    The *view-renderer.js* module transforms and caches the react view components at runtime.
                                </p>
                            </InfoBlock>
                    }
                }
            />
    });
});

markDownPages.sort(
    prioritySort([
        "index",
        "concept",
        "models-about",
        "models-domain",
        "models-view",
        "models-unified",
        "page-types",
        "models-process",
        "page-action",
        "page-graph"
    ], 1, e => e.name)
);


const content = markDownPages.concat(
    {
        name: "model-reference",
        title: "Model Reference",
        component: <ModelDocs {...modelDocsData}/>
    },
    {
        name: "component",
        title: "Component Reference",
        component: <ComponentDocs data={ componentData }/>
    },
    {
        name: "expression",
        title: "Expression Reference",
        component: <ExpressionDocs definitions={ modelDocsData.definitions }/>
    },
    {
        name: "query-expression",
        title: "Query Expression Reference",
        component:
            <ExpressionDocs
                definitions={ modelDocsData.QueryTransformerOperations }
                chapterOrder={ ["QueryDefinition","QueryDomainType", "JoinDefinition"] }
                intros={{
                    "QueryDefinition" : fs.readFileSync(DOC_SOURCE + "/intro/querydef.md", "UTF-8"),
                    "QueryDomainType" : fs.readFileSync(DOC_SOURCE + "/intro/querytype.md", "UTF-8"),
                }}
                expressionType="java"
                noDefTypes={ true }
            />
    },
    {
        name: "filter-expression",
        title: "Filter Expression Reference",
        component:
            <ExpressionDocs
                definitions={ modelDocsData.QueryFilterOperations }
                intros={{
                    "Field" : fs.readFileSync(DOC_SOURCE + "/intro/field.md", "UTF-8"),
                }}
                expressionType="java"
                noDefTypes={ true }
            />
    },
    {
        name: "class-index",
        title: "Components by class",
        component: <ComponentClassIndex descriptors={ componentData.descriptors }/>
    }
);

for (let i = 0; i < content.length; i++)
{
    renderDoc(OUTPUT, content, i);
}
