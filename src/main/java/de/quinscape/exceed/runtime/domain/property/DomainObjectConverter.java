package de.quinscape.exceed.runtime.domain.property;

import de.quinscape.exceed.model.domain.property.DomainProperty;
import de.quinscape.exceed.model.domain.type.DomainType;
import de.quinscape.exceed.model.meta.PropertyType;
import de.quinscape.exceed.runtime.ExceedRuntimeException;
import de.quinscape.exceed.runtime.RuntimeContext;
import de.quinscape.exceed.runtime.domain.DomainObject;
import de.quinscape.exceed.runtime.domain.GeneratedDomainObject;
import de.quinscape.exceed.runtime.domain.GenericDomainObject;
import de.quinscape.exceed.runtime.js.JsEnvironment;
import de.quinscape.exceed.runtime.js.env.InspectUtil;
import de.quinscape.exceed.runtime.js.env.SvensonJsAdapter;
import jdk.nashorn.api.scripting.JSObject;
import jdk.nashorn.api.scripting.ScriptObjectMirror;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by sven on 12.07.17.
 */
public class DomainObjectConverter
    implements PropertyConverter<DomainObject, Map, JSObject>
{
    /**
     * Configuration key for implementation class.
     *
     * @see #getImplementationClass(Map) 
     */
    public static final String IMPLEMENTATION_CONFIG = "implementation";

    private final String domainType;

    private final Class<? extends DomainObject> cls;


    public DomainObjectConverter(String domainType, Class<? extends DomainObject> cls)
    {
        this.domainType = domainType;
        this.cls = cls;
    }


    @Override
    public DomainObject convertToJava(RuntimeContext runtimeContext, Map value)
    {
        if (value == null)
        {
            return null;
        }

        DomainObject domainObject = runtimeContext.getDomainService().create(
            runtimeContext, getType(value),
            (String)value.get(DomainType.ID_PROPERTY),
            cls
        );

        final DomainType domainTypeModel = runtimeContext.getDomainService().getDomainType(getType(value));

        for (DomainProperty property : domainTypeModel.getProperties())
        {
            final String name = property.getName();

            final Object converted = property.getPropertyType().convertToJava(runtimeContext, value.get(name));

            domainObject.setProperty(name, converted);
        }

        return domainObject;

    }


    private String getType(Map value)
    {
        if (domainType != null)
        {
            return domainType;
        }
        return (String) value.get("_type");
    }

    private String getType(DomainObject value)
    {
        if (domainType != null)
        {
            return domainType;
        }
        return value.getDomainType();
    }

    private String getType(JSObject value)
    {
        if (domainType != null)
        {
            return domainType;
        }
        final Object type = value.getMember("_type");

        if (!(type instanceof String))
        {
            throw new IllegalStateException("Cannot get type of: " + InspectUtil.inspect(value));
        }

        return (String) type;
    }

    @Override
    public Map<String, Object> convertToJSON(RuntimeContext runtimeContext, DomainObject value)
    {
        if (value == null)
        {
            return null;
        }

        final Map<String, Object> domainObject = new HashMap<>();
        domainObject.put(DomainType.TYPE_PROPERTY, value.getDomainType());

        final DomainType domainTypeModel = runtimeContext.getDomainService().getDomainType(getType(value));

        for (DomainProperty property : domainTypeModel.getProperties())
        {
            final String name = property.getName();

            final Object converted = property.getPropertyType().convertToJSON(runtimeContext, value.getProperty(name));

            domainObject.put(name, converted);
        }

        return domainObject;
    }


    @Override
    public Class<DomainObject> getJavaType()
    {
        return DomainObject.class;
    }


    @Override
    public Class<Map> getJSONType()
    {
        return Map.class;
    }


    /**
     * Returns the domain object implementation class for the given config map. The default is {@link GenericDomainObject},
     * which is a general all purpose domain object container that can contain any domain object of any domain.
     * <p>
     *     Additionally, you can use maven and JOOQ to generate POJO implementations for the database as generated
     *     by the current model of an application.
     * </p>
     * <p>
     *     The POJOS generated by this process will have the domain type name as Java simple class name and will
     *     only work as container for this domain type or domain types with compatible property / column structure.
     * </p>
     *
     * @param config    config map
     *                  
     * @return  Java class to use as container for the converter/property.
     *
     * @see #IMPLEMENTATION_CONFIG
     */
    public static Class<? extends DomainObject> getImplementationClass(Map<String,Object> config)
    {
        if (config != null)
        {
            final String name = (String) config.get(IMPLEMENTATION_CONFIG);
            if (name != null)
            {
                final Class<?> cls;
                try
                {
                    cls = Class.forName(name);
                }
                catch (ClassNotFoundException e)
                {
                    throw new ExceedRuntimeException("Domain class implementation not found", e);
                }
                if (!DomainObject.class.isAssignableFrom(cls))
                {
                    throw new IllegalStateException( name + " does not implement " + DomainObject.class);
                }
                return (Class<GeneratedDomainObject>) cls;
            }
        }
        return GenericDomainObject.class;
    }


    @Override
    public JSObject convertToJs(RuntimeContext runtimeContext, DomainObject value)
    {
        if (value == null)
        {
            return null;
        }

        final String domainType = getType(value);
        GenericDomainObject domainObject = new GenericDomainObject();
        domainObject.setDomainService(runtimeContext.getDomainService());
        domainObject.setDomainType(domainType);

        final JsEnvironment jsEnvironment = runtimeContext.getJsEnvironment();
        final DomainType domainTypeModel = runtimeContext.getDomainService().getDomainType(domainType);

        for (DomainProperty propertyModel : domainTypeModel.getProperties())
        {
            final String name = propertyModel.getName();
            final Object propertyValue = value.getProperty(name);

            try
            {
                final PropertyType propertyType = PropertyType.get(
                    runtimeContext,
                    propertyModel
                );
                final Object converted = propertyType.convertToJs(runtimeContext, propertyValue);
                domainObject.setProperty(name, converted);
            }
            catch(Exception e)
            {
                throw new ConversionFailureException("Error converting " + domainType + "." + name,e);
            }

        }

        return (JSObject) SvensonJsAdapter.wrap(domainObject);
    }


    @Override
    public DomainObject convertFromJs(RuntimeContext runtimeContext, JSObject value)
    {
        if (value == null)
        {
            return null;
        }

        Object unwrapped = SvensonJsAdapter.unwrap(value);
        final DomainObject domainObject;
        final String domainType = getType(value);
        final Object idProp = value.getMember(DomainType.ID_PROPERTY);

        if (cls.isInstance(unwrapped))
        {
            domainObject = (DomainObject) unwrapped;
        }
        else
        {
            domainObject = runtimeContext.getDomainService().create(
                runtimeContext, domainType,
                idProp != null ? idProp.toString() : null,
                cls
            );
        }

        final DomainType domainTypeModel = runtimeContext.getDomainService().getDomainType(domainType);

        final JsEnvironment jsEnvironment = runtimeContext.getJsEnvironment();

        for (DomainProperty propertyModel : domainTypeModel.getProperties())
        {
            final String name = propertyModel.getName();

            final Object propertyValue = value.getMember(name);

            if (propertyValue != null && !ScriptObjectMirror.isUndefined(propertyValue))
            {
                final PropertyType propertyType = PropertyType.get(
                    runtimeContext,
                    propertyModel
                );
                final Object converted = propertyType.convertFromJs(runtimeContext, propertyValue);
                domainObject.setProperty(name, converted);
            }
        }
        return domainObject;
    }
}
