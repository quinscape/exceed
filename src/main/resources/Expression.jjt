
options {
    MULTI=true;
    VISITOR=true;
    NODE_DEFAULT_VOID=true;
    STATIC=false;
}

PARSER_BEGIN(ExpressionParser)
package de.quinscape.exceed.expression;

import de.quinscape.exceed.expression.ExpressionParserConstants;
import de.quinscape.exceed.runtime.ExceedRuntimeException;
import de.quinscape.exceed.runtime.util.Util;
import java.io.Reader;
import java.io.StringReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;

/**
 * Parses the exceed expression language in a tree of AST nodes.
 *
 * generated by the grammar in src/main/resources/Expression.jjt
 *
 */
public class ExpressionParser
{
    private final static Logger log = LoggerFactory.getLogger(ExpressionParser.class);

    public static ASTExpression parse(String expression) throws ParseException
    {
        if (expression == null || expression.length() == 0)
        {
            return null;
        }
        return parse(new StringReader(expression));
    }


    public static ASTExpression parse(Reader reader) throws ParseException
    {
        ExpressionParser t = new ExpressionParser(reader);
        ASTExpression expression = t.Expression();

        Token next = t.token.next;
        if (next.kind != ExpressionParserConstants.EOF)
        {
            throw t.generateParseException();
        }
        return expression;
    }
}

PARSER_END(ExpressionParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : /* LITERALS */
{
    <NULL: "null">
|
  < BOOLEAN_LITERAL: ("true" | "false")>
|
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < FRACTIONAL_LITERAL:
    (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
    | "." (["0"-"9"])+ (<EXPONENT>)?
    | (["0"-"9"])+ <EXPONENT>
    | (["0"-"9"])+ (<EXPONENT>)?
    >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

/**
 * Uncomment for double quoted strings (also below in String()
TOKEN:
{
  <DQUOTED_STRING: "\"" ( <DQ_ALLOWABLE_CHARACTERS> )* "\"" >
| <#DQ_ALLOWABLE_CHARACTERS:(
    (~["\"", "\\", "\u0000"-"\u001f"])
    | ("\\"
        ( ["u"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"]
          | ["\"", "\\", "b", "f", "n", "r", "t"]
        )
      )
    )
  >
}
*/

TOKEN:
{
  <SQUOTED_STRING: "\'" ( <SQ_ALLOWABLE_CHARACTERS> )* "\'" >
| <#SQ_ALLOWABLE_CHARACTERS:(
    (~["\'", "\\", "\u0000"-"\u001f"])
    | ("\\"
        ( ["u"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"] ["0"-"9","a"-"f", "A"-"F"]
          | ["\'", "\\", "b", "f", "n", "r", "t"]
        )
    )
  )
  >
}


/** Expression root production. */
ASTExpression Expression() #Expression : {}
{
  Expr()
  { return jjtThis; }
}


/** Expression. */
void Expr() : {}
{
    ExpressionSequence()
}

/** An expression sequence. */
void ExpressionSequence() : {}
{
    (
    AssignmentExpression() ( ";" AssignmentExpression() )*
    ) #ExpressionSequence(>1)
}


/** An or expression. */
void AssignmentExpression() : {}
{
    (
        OrExpression() ( "=" OrExpression())*
    ) #Assignment(jjtree.nodeArity() == 2)
}

/** An or expression. */
void OrExpression() : {}
{
    (
    AndExpression() ( "||" AndExpression() )*
    ) #LogicalOr(>1)
}

/** An and expression. */
void AndExpression() : {}
{
    (
        EqualityExpression() ( "&&" EqualityExpression() )*
    ) #LogicalAnd(>1)
}

/** An equality Expression. */
void EqualityExpression() :
{
    Token op = null;
}
{
    (
        RelationalExpression() ( ( op = "==" | op = "!=" ) RelationalExpression() )?
    ) #Equality(jjtree.nodeArity() == 2)
    {

        if (jjtree.nodeCreated() && op != null)
{
            if (op.image.equals("=="))
            {
                ((OperatorNode)jjtree.peekNode()).setOperator(Operator.EQUALS);
}
            else if (op.image.equals("!="))
{
                ((OperatorNode)jjtree.peekNode()).setOperator(Operator.NOT_EQUALS);
            }
        }
    }
}

/** An relational Expression. */
void RelationalExpression():
{
Token op = null;
}
{
    (
        AdditionExpression() ( ( op = "<" | op = "<=" | op = ">" | op = ">=" ) AdditionExpression() )?
    ) #Relational(jjtree.nodeArity() == 2)
    {
        if (jjtree.nodeCreated() && op != null)
        {
            if (op.image.equals("<"))
            {
                ((OperatorNode)jjtree.peekNode()).setOperator(Operator.LESS);
            }
            else if (op.image.equals("<="))
            {
                ((OperatorNode)jjtree.peekNode()).setOperator(Operator.LESS_OR_EQUALS);
            }
            else if (op.image.equals(">"))
            {
                ((OperatorNode)jjtree.peekNode()).setOperator(Operator.GREATER);
            }
            else if (op.image.equals(">="))
            {
                ((OperatorNode)jjtree.peekNode()).setOperator(Operator.GREATER_OR_EQUALS);
            }
        }
    }
}

/** An Additive Expression. */
void AdditionExpression() :
{
}
{
  (
    SubtractionExpression() ( "+" SubtractionExpression() )*
  ) #Add(>1)
}

/** An Additive Expression. */
void SubtractionExpression() :
    {
    }
    {
    (
     MultiplicationExpression() ( "-" MultiplicationExpression() )*
    ) #Sub(>1)
    }

/** A Multiplicative Expression. */
void MultiplicationExpression() :
{
}
{
  (
    DivisionExpression() ( "*" DivisionExpression() )*
  ) #Mult(>1)
}

/** A Multiplicative Expression. */
void DivisionExpression() :
{
}
{
  (
    NotExpression() ( "/" NotExpression() )*
  ) #Div(>1)
}

/** A Not Expression. */
void NotExpression() :
{
    Token op = null;
}
{
    (( op = "!" )? NegateExpression() ) #Not(op != null)
}

/** A Negate Expression. */
void NegateExpression() :
{
    Token op = null;
}
{
    (( op = "-" )? PropertyChainExpression() ) #Negate(op != null)
}

/** A Property Access. */
void PropertyChainExpression() : {}
{
    (
        // property access and methods
        ValueExpression() ( PropertyChainDot() | PropertyChainSquare() )*
    ) #PropertyChain(>1)
}

/** A Property Access. */
void PropertyChainDot() : {}
{
    (
        "." PropertyAccessor()
    ) #PropertyChainDot
}


/** A Property Access. */
void PropertyChainSquare() : {}
{
    (
        "[" Expr() "]"
    ) #PropertyChainSquare
}


void PropertyAccessor() : {}
{
    LOOKAHEAD(2) Function() |
    Identifier()
}


/** A Unary Expression. */
void ValueExpression() : {}
{
    "(" Expression() ")" |
    LOOKAHEAD(2) Function() |
    Identifier() |
    String() |
    Map() |
    Array() |
    Decimal() |
    Integer() |
    Bool() |
    Null()
}

/** An Identifier. */
void Identifier() #Identifier :
{
  Token t;
}
{
  t=<IDENTIFIER>
  {
    jjtThis.setName(t.image);
  }
}


/** A function call. */
void Function() #Function :
{
Token t;
}
{
  t=<IDENTIFIER> "(" (Expr() ( "," Expr() )* )? ")"
  {
    jjtThis.setName(t.image);
  }
}

/** An Integer. */
void Integer() #Integer :
{
Token t;
}
{
  t = <INTEGER_LITERAL>
  {
    jjtThis.setValue(Integer.parseInt(t.image));
  }
}

/** An String literal. */
void String() #String :
{
    Token t;
}
{
    //<DQUOTED_STRING> | <SQUOTED_STRING>
    t = <SQUOTED_STRING>

    {
        jjtThis.setValue(Util.parseSingleQuotedString(t.image));
    }
}

/** A Map literal. */
void Map() #Map:
{
}
{
    "{" ( MapEntry() ( "," MapEntry() )* )? "}"
}

/** A Map literal. */
void Array() #Array:
{
}
{
    "[" ( Expr() ( "," Expr() )* )? "]"
}

/** A MapEntry literal. */
void MapEntry() #MapEntry:
{
}
{
    ( String() | Identifier() ) ":" Expr()
}

/** An decimal number literal with fractional digits. */
void Decimal() #Decimal :
{
    Token t;
}
{
    t = <FRACTIONAL_LITERAL>

    {
        jjtThis.setValue(new BigDecimal(t.image));
    }
}

/** An boolean literal. */
void Bool() #Bool :
{
    Token t;
}
{
    t = <BOOLEAN_LITERAL>

    {
        jjtThis.setValue(Boolean.valueOf(t.image));
    }
}

/** A null literal. */
void Null() #Null : {}
{
    <NULL>
}
